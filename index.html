<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Scanner V16.3 - Geometry Fix</title>
    <script src="https://unpkg.com/@zxing/library@0.18.6/umd/index.min.js"></script>
    <script async src="https://docs.opencv.org/4.5.0/opencv.js" id="opencv-script"></script>
    <style>
        :root { --primary: #0f0; --industrial: #f1c40f; --bg: #0a0a0a; }
        body { margin: 0; padding: 10px; background: var(--bg); color: white; font-family: monospace; display: flex; flex-direction: column; align-items: center; }
        .scanner-window { position: relative; width: 280px; height: 280px; border-radius: 15px; overflow: hidden; border: 2px solid #444; }
        video { width: 100%; height: 100%; object-fit: cover; }
        #roi-guide { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); border: 2px solid var(--primary); pointer-events: none; z-index: 10; width: 100%; height: 100%; }
        #debugCanvas { margin-top: 10px; width: 260px; height: 260px; background: #111; border: 4px solid #333; transition: border-color 0.2s; image-rendering: pixelated; }
        #debugCanvas.analyzing { border-color: #007bff; }
        .filter-panel { width: 300px; background: #111; padding: 10px; margin-top: 10px; border-radius: 10px; border: 1px solid #333; display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .filter-opt { font-size: 0.65rem; display: flex; align-items: center; gap: 5px; color: #ccc; }
        .btn { width: 300px; padding: 15px; margin-top: 10px; border-radius: 8px; border: none; font-weight: bold; background: var(--primary); cursor: pointer; color: black; }
        #progress-bar { width: 300px; height: 6px; background: #333; margin-top: 5px; border-radius: 3px; overflow: hidden; }
        #progress-fill { width: 0%; height: 100%; background: var(--primary); }
    </style>
</head>
<body>

    <div style="font-size: 0.7rem; color: var(--industrial); margin-bottom: 5px;">V16.3: CORRECCIÓN GEOMÉTRICA</div>

    <div class="scanner-window">
        <video id="video" playsinline muted autoplay></video>
        <div id="roi-guide"></div>
    </div>

    <canvas id="debugCanvas"></canvas>
    <div id="progress-bar"><div id="progress-fill"></div></div>

    <div class="filter-panel">
        <label class="filter-opt"><input type="checkbox" id="read_std"> ESTÁNDAR</label>
        <label class="filter-opt"><input type="checkbox" id="f_inv"> INVERTIR</label>
        <label class="filter-opt"><input type="checkbox" id="f_adapt" checked> ADAPTATIVO</label>
        <label class="filter-opt"><input type="checkbox" id="f_dilate"> DILATAR</label>
        <label class="filter-opt"><input type="checkbox" id="f_sharp" checked> AGUDIZAR</label>
        <label class="filter-opt"><input type="checkbox" id="f_skew" checked> ANTI-ÁNGULO</label>
        <div style="grid-column: span 2;">
            <input type="range" id="zoom_range" min="0.2" max="1.0" step="0.05" value="1.0" style="width: 100%;">
        </div>
    </div>

    <button id="btn-start" class="btn" onclick="startSystem()">INICIAR V16.3</button>

    <script>
        const codeReader = new ZXing.BrowserMultiFormatReader();
        const video = document.getElementById('video');
        const debugCanvas = document.getElementById('debugCanvas');
        const roiGuide = document.getElementById('roi-guide');
        const zoomRange = document.getElementById('zoom_range');
        
        let openCVReady = false;
        let isPaused = false;
        
        const GRID = 50; 
        let accumulator = new Int32Array(GRID * GRID).fill(0);
        let framesCount = 0;
        const MAX_FRAMES = 12;

        document.getElementById('opencv-script').onload = () => { openCVReady = true; };

        zoomRange.oninput = function() {
            const val = parseFloat(this.value);
            roiGuide.style.width = (val * 100) + "%";
            roiGuide.style.height = (val * 100) + "%";
        };

        async function startSystem() {
            try {
                // Configuración más relajada inicialmente para evitar el doble permiso
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: "environment", width: { ideal: 640 }, height: { ideal: 640 } } 
                });
                video.srcObject = stream;
                document.getElementById('btn-start').style.display = 'none';
                setInterval(mainLoop, 120);
                runStandardReader();
            } catch (e) { alert("Permiso denegado o error: " + e); }
        }

        function runStandardReader() {
            codeReader.decodeFromVideoDevice(null, 'video', (res) => {
                if (res && document.getElementById('read_std').checked) onSuccess(res.text, "DIRECTO");
            });
        }

        function mainLoop() {
            if (!openCVReady || video.readyState !== video.HAVE_ENOUGH_DATA || isPaused) return;

            // --- CORRECCIÓN GEOMÉTRICA 1:1 ---
            const vW = video.videoWidth;
            const vH = video.videoHeight;
            const minDim = Math.min(vW, vH); // Usamos la dimensión mínima para asegurar un cuadrado
            
            const zoom = parseFloat(zoomRange.value);
            const roiSize = minDim * zoom;
            
            // Centrado exacto basado en la dimensión cuadrada
            const startX = (vW - roiSize) / 2;
            const startY = (vH - roiSize) / 2;

            const tCanvas = document.createElement('canvas');
            tCanvas.width = 300; tCanvas.height = 300;
            const tctx = tCanvas.getContext('2d');
            
            // Dibujamos de forma cuadrada explícita
            tctx.drawImage(video, startX, startY, roiSize, roiSize, 0, 0, 300, 300);

            let src = cv.imread(tCanvas);
            let dst = new cv.Mat();
            cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY);

            // Filtros
            if (document.getElementById('f_sharp').checked) {
                let kernel = cv.matFromArray(3, 3, cv.CV_32F, [0, -1, 0, -1, 5, -1, 0, -1, 0]);
                cv.filter2D(dst, dst, cv.CV_8U, kernel); kernel.delete();
            }
            if (document.getElementById('f_skew').checked) cv.GaussianBlur(dst, dst, new cv.Size(3, 3), 0);
            
            if (document.getElementById('f_adapt').checked) {
                cv.adaptiveThreshold(dst, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 13, 2);
            } else {
                cv.threshold(dst, dst, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU);
            }

            if (document.getElementById('f_inv').checked) cv.bitwise_not(dst, dst);
            if (document.getElementById('f_dilate').checked) {
                let M = cv.Mat.ones(2, 2, cv.CV_8U);
                cv.erode(dst, dst, M); M.delete();
            }

            // Acumular
            framesCount++;
            for (let i = 0; i < GRID * GRID; i++) {
                let x = i % GRID; let y = Math.floor(i / GRID);
                let pixel = dst.ucharAt(y * (300/GRID), x * (300/GRID));
                if (pixel === 0) accumulator[i]++;
            }

            renderAccumulator();
            document.getElementById('progress-fill').style.width = (framesCount / MAX_FRAMES * 100) + "%";

            if (framesCount >= MAX_FRAMES) processResult();

            src.delete(); dst.delete();
        }

        function renderAccumulator() {
            const outCtx = debugCanvas.getContext('2d');
            const size = 320; 
            debugCanvas.width = size; debugCanvas.height = size;
            outCtx.fillStyle = "white"; 
            outCtx.fillRect(0,0, size, size);
            
            const margin = 30;
            const drawArea = size - (margin * 2);
            const cellSize = drawArea / GRID;

            for (let i = 0; i < accumulator.length; i++) {
                let x = i % GRID; let y = Math.floor(i / GRID);
                if (accumulator[i] > (framesCount * 0.55)) { // Umbral de voto
                    outCtx.fillStyle = "black";
                    outCtx.fillRect(margin + (x * cellSize), margin + (y * cellSize), cellSize + 0.5, cellSize + 0.5);
                }
            }
        }

        async function processResult() {
            isPaused = true;
            debugCanvas.classList.add('analyzing');
            try {
                const res = await codeReader.decodeFromCanvas(debugCanvas);
                if (res) onSuccess(res.text, "GEOMETRÍA OK");
            } catch (e) {}
            
            await new Promise(r => setTimeout(r, 1000));
            framesCount = 0;
            accumulator.fill(0);
            debugCanvas.classList.remove('analyzing');
            isPaused = false;
        }

        function onSuccess(t, m) {
            if (navigator.vibrate) navigator.vibrate(200);
            alert(`LEÍDO (${m}):\n${t}`);
            location.reload();
        }
    </script>
</body>
</html>
